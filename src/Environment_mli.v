(** File generated by coq-of-ocaml *)
Require Import CoqOfOCaml.CoqOfOCaml.
Require Import CoqOfOCaml.Settings.

Module Pervasives.
  Parameter raise : forall {a : Set}, extensible_type -> a.
  
  Parameter raise_notrace : forall {a : Set}, extensible_type -> a.
  
  Parameter invalid_arg : forall {a : Set}, string -> a.
  
  Parameter failwith : forall {a : Set}, string -> a.
  
  Parameter not : bool -> bool.
  
  Parameter op_andand : bool -> bool -> bool.
  
  Parameter op_pipepipe : bool -> bool -> bool.
  
  Parameter __LOC__ : string.
  
  Parameter __FILE__ : string.
  
  Parameter __LINE__ : int.
  
  Parameter __MODULE__ : string.
  
  Parameter __POS__ : string * int * int * int.
  
  Parameter __LOC_OF__ : forall {a : Set}, a -> string * a.
  
  Parameter __LINE_OF__ : forall {a : Set}, a -> int * a.
  
  Parameter __POS_OF__ : forall {a : Set}, a -> (string * int * int * int) * a.
  
  Parameter op_pipegt : forall {a b : Set}, a -> (a -> b) -> b.
  
  Parameter op_atat : forall {a b : Set}, (a -> b) -> a -> b.
  
  Parameter op_tildeminus : int -> int.
  
  Parameter op_tildeplus : int -> int.
  
  Parameter succ : int -> int.
  
  Parameter pred : int -> int.
  
  Parameter op_plus : int -> int -> int.
  
  Parameter op_minus : int -> int -> int.
  
  Parameter op_star : int -> int -> int.
  
  Parameter op_div : int -> int -> int.
  
  Parameter _mod : int -> int -> int.
  
  Parameter abs : int -> int.
  
  Parameter max_int : int.
  
  Parameter min_int : int.
  
  Parameter land : int -> int -> int.
  
  Parameter lor : int -> int -> int.
  
  Parameter lxor : int -> int -> int.
  
  Parameter lnot : int -> int.
  
  Parameter lsl : int -> int -> int.
  
  Parameter lsr : int -> int -> int.
  
  Parameter asr : int -> int -> int.
  
  Parameter op_caret : string -> string -> string.
  
  Parameter int_of_char : ascii -> int.
  
  Parameter char_of_int : int -> ascii.
  
  Parameter ignore : forall {a : Set}, a -> unit.
  
  Parameter string_of_bool : bool -> string.
  
  Parameter bool_of_string_opt : string -> option bool.
  
  Parameter string_of_int : int -> string.
  
  Parameter int_of_string_opt : string -> option int.
  
  Parameter fst : forall {a b : Set}, a * b -> a.
  
  Parameter snd : forall {a b : Set}, a * b -> b.
  
  Parameter op_at : forall {a : Set}, list a -> list a -> list a.
  
  Module ref.
    Record record {a : Set} : Set := Build {
      contents : a }.
    Arguments record : clear implicits.
    Definition with_contents {t_a} contents (r : record t_a) :=
      Build t_a contents.
  End ref.
  Definition ref := ref.record.
  
  Parameter ref_value : forall {a : Set}, a -> ref a.
  
  Parameter op_exclamation : forall {a : Set}, ref a -> a.
  
  Parameter op_coloneq : forall {a : Set}, ref a -> a -> unit.
  
  Parameter incr : ref int -> unit.
  
  Parameter decr : ref int -> unit.
  
  Inductive result (a b : Set) : Set :=
  | Ok : a -> result a b
  | Error : b -> result a b.
  
  Arguments Ok {_ _}.
  Arguments Error {_ _}.
  
  Definition format6 (a b c d e f : Set) : Set :=
    CamlinternalFormatBasics.format6 a b c d e f.
  
  Definition format4 (a b c d : Set) : Set := format6 a b c c c d.
  
  Definition format (a b c : Set) : Set := format4 a b c c.
  
  Parameter string_of_format : forall {a b c d e f : Set},
    format6 a b c d e f -> string.
  
  Parameter format_of_string : forall {a b c d e f : Set},
    format6 a b c d e f -> format6 a b c d e f.
  
  Parameter op_caretcaret : forall {a b c d e f g h : Set},
    format6 a b c d e f -> format6 f b c e g h -> format6 a b c d g h.
End Pervasives.

Module Either.
  Inductive t (a b : Set) : Set :=
  | Left : a -> t a b
  | Right : b -> t a b.
  
  Arguments Left {_ _}.
  Arguments Right {_ _}.
  
  Parameter equal : forall {a b : Set},
    (a -> a -> bool) -> (b -> b -> bool) -> t a b -> t a b -> bool.
  
  Parameter compare : forall {a b : Set},
    (a -> a -> int) -> (b -> b -> int) -> t a b -> t a b -> int.
End Either.

Module String.
  Parameter length : string -> int.
  
  Parameter get : string -> int -> ascii.
  
  Parameter make : int -> ascii -> string.
  
  Parameter init_value : int -> (int -> ascii) -> string.
  
  Parameter sub : string -> int -> int -> string.
  
  Parameter blit : string -> int -> bytes -> int -> int -> unit.
  
  Parameter concat : string -> list string -> string.
  
  Parameter iter : (ascii -> unit) -> string -> unit.
  
  Parameter iteri : (int -> ascii -> unit) -> string -> unit.
  
  Parameter map : (ascii -> ascii) -> string -> string.
  
  Parameter mapi : (int -> ascii -> ascii) -> string -> string.
  
  Parameter trim : string -> string.
  
  Parameter escaped : string -> string.
  
  Parameter index_opt : string -> ascii -> option int.
  
  Parameter rindex_opt : string -> ascii -> option int.
  
  Parameter index_from_opt : string -> int -> ascii -> option int.
  
  Parameter rindex_from_opt : string -> int -> ascii -> option int.
  
  Parameter contains : string -> ascii -> bool.
  
  Parameter contains_from : string -> int -> ascii -> bool.
  
  Parameter rcontains_from : string -> int -> ascii -> bool.
  
  Parameter uppercase_ascii : string -> string.
  
  Parameter lowercase_ascii : string -> string.
  
  Parameter capitalize_ascii : string -> string.
  
  Parameter uncapitalize_ascii : string -> string.
  
  Definition t : Set := string.
  
  Parameter compare : t -> t -> int.
  
  Parameter equal : t -> t -> bool.
  
  Parameter split_on_char : ascii -> string -> list string.
End String.

Module Char.
  Parameter code : ascii -> int.
  
  Parameter chr : int -> ascii.
  
  Parameter escaped : ascii -> string.
  
  Parameter lowercase_ascii : ascii -> ascii.
  
  Parameter uppercase_ascii : ascii -> ascii.
  
  Definition t : Set := ascii.
  
  Parameter compare : t -> t -> int.
  
  Parameter equal : t -> t -> bool.
End Char.

Module Bytes.
  Parameter length : bytes -> int.
  
  Parameter get : bytes -> int -> ascii.
  
  Parameter set : bytes -> int -> ascii -> unit.
  
  Parameter make : int -> ascii -> bytes.
  
  Parameter init_value : int -> (int -> ascii) -> bytes.
  
  Parameter empty : bytes.
  
  Parameter copy : bytes -> bytes.
  
  Parameter of_string : string -> bytes.
  
  Parameter to_string : bytes -> string.
  
  Parameter sub : bytes -> int -> int -> bytes.
  
  Parameter sub_string : bytes -> int -> int -> string.
  
  Parameter extend : bytes -> int -> int -> bytes.
  
  Parameter fill : bytes -> int -> int -> ascii -> unit.
  
  Parameter blit : bytes -> int -> bytes -> int -> int -> unit.
  
  Parameter blit_string : string -> int -> bytes -> int -> int -> unit.
  
  Parameter concat : bytes -> list bytes -> bytes.
  
  Parameter cat : bytes -> bytes -> bytes.
  
  Parameter iter : (ascii -> unit) -> bytes -> unit.
  
  Parameter iteri : (int -> ascii -> unit) -> bytes -> unit.
  
  Parameter map : (ascii -> ascii) -> bytes -> bytes.
  
  Parameter mapi : (int -> ascii -> ascii) -> bytes -> bytes.
  
  Parameter trim : bytes -> bytes.
  
  Parameter escaped : bytes -> bytes.
  
  Parameter index_opt : bytes -> ascii -> option int.
  
  Parameter rindex_opt : bytes -> ascii -> option int.
  
  Parameter index_from_opt : bytes -> int -> ascii -> option int.
  
  Parameter rindex_from_opt : bytes -> int -> ascii -> option int.
  
  Parameter contains : bytes -> ascii -> bool.
  
  Parameter contains_from : bytes -> int -> ascii -> bool.
  
  Parameter rcontains_from : bytes -> int -> ascii -> bool.
  
  Parameter uppercase_ascii : bytes -> bytes.
  
  Parameter lowercase_ascii : bytes -> bytes.
  
  Parameter capitalize_ascii : bytes -> bytes.
  
  Parameter uncapitalize_ascii : bytes -> bytes.
  
  Definition t : Set := bytes.
  
  Parameter compare : t -> t -> int.
  
  Parameter equal : t -> t -> bool.
End Bytes.

Module Int32.
  Parameter zero : int32.
  
  Parameter one : int32.
  
  Parameter minus_one : int32.
  
  Parameter neg : int32 -> int32.
  
  Parameter add : int32 -> int32 -> int32.
  
  Parameter sub : int32 -> int32 -> int32.
  
  Parameter mul : int32 -> int32 -> int32.
  
  Parameter div : int32 -> int32 -> int32.
  
  Parameter rem : int32 -> int32 -> int32.
  
  Parameter succ : int32 -> int32.
  
  Parameter pred : int32 -> int32.
  
  Parameter abs : int32 -> int32.
  
  Parameter max_int : int32.
  
  Parameter min_int : int32.
  
  Parameter logand : int32 -> int32 -> int32.
  
  Parameter logor : int32 -> int32 -> int32.
  
  Parameter logxor : int32 -> int32 -> int32.
  
  Parameter lognot : int32 -> int32.
  
  Parameter shift_left : int32 -> int -> int32.
  
  Parameter shift_right : int32 -> int -> int32.
  
  Parameter shift_right_logical : int32 -> int -> int32.
  
  Parameter of_int : int -> int32.
  
  Parameter to_int : int32 -> int.
  
  Parameter of_string_opt : string -> option int32.
  
  Parameter to_string : int32 -> string.
  
  Definition t : Set := int32.
  
  Parameter compare : t -> t -> int.
  
  Parameter equal : t -> t -> bool.
End Int32.

Module Int64.
  Parameter zero : int64.
  
  Parameter one : int64.
  
  Parameter minus_one : int64.
  
  Parameter neg : int64 -> int64.
  
  Parameter add : int64 -> int64 -> int64.
  
  Parameter sub : int64 -> int64 -> int64.
  
  Parameter mul : int64 -> int64 -> int64.
  
  Parameter div : int64 -> int64 -> int64.
  
  Parameter rem : int64 -> int64 -> int64.
  
  Parameter succ : int64 -> int64.
  
  Parameter pred : int64 -> int64.
  
  Parameter abs : int64 -> int64.
  
  Parameter max_int : int64.
  
  Parameter min_int : int64.
  
  Parameter logand : int64 -> int64 -> int64.
  
  Parameter logor : int64 -> int64 -> int64.
  
  Parameter logxor : int64 -> int64 -> int64.
  
  Parameter lognot : int64 -> int64.
  
  Parameter shift_left : int64 -> int -> int64.
  
  Parameter shift_right : int64 -> int -> int64.
  
  Parameter shift_right_logical : int64 -> int -> int64.
  
  Parameter of_int : int -> int64.
  
  Parameter to_int : int64 -> int.
  
  Parameter of_int32 : int32 -> int64.
  
  Parameter to_int32 : int64 -> int32.
  
  Parameter of_string_opt : string -> option int64.
  
  Parameter to_string : int64 -> string.
  
  Definition t : Set := int64.
  
  Parameter compare : t -> t -> int.
  
  Parameter equal : t -> t -> bool.
End Int64.

Module Format.
  Parameter formatter : Set.
  
  Parameter pp_open_box : formatter -> int -> unit.
  
  Parameter pp_close_box : formatter -> unit -> unit.
  
  Parameter pp_open_hbox : formatter -> unit -> unit.
  
  Parameter pp_open_vbox : formatter -> int -> unit.
  
  Parameter pp_open_hvbox : formatter -> int -> unit.
  
  Parameter pp_open_hovbox : formatter -> int -> unit.
  
  Parameter pp_print_string : formatter -> string -> unit.
  
  Parameter pp_print_as : formatter -> int -> string -> unit.
  
  Parameter pp_print_int : formatter -> int -> unit.
  
  Parameter pp_print_char : formatter -> ascii -> unit.
  
  Parameter pp_print_bool : formatter -> bool -> unit.
  
  Parameter pp_print_space : formatter -> unit -> unit.
  
  Parameter pp_print_cut : formatter -> unit -> unit.
  
  Parameter pp_print_break : formatter -> int -> int -> unit.
  
  Parameter pp_print_custom_break :
    formatter -> string * int * string -> string * int * string -> unit.
  
  Parameter pp_force_newline : formatter -> unit -> unit.
  
  Parameter pp_print_if_newline : formatter -> unit -> unit.
  
  Parameter pp_print_flush : formatter -> unit -> unit.
  
  Parameter pp_print_newline : formatter -> unit -> unit.
  
  Parameter pp_set_margin : formatter -> int -> unit.
  
  Parameter pp_get_margin : formatter -> unit -> int.
  
  Parameter pp_set_max_indent : formatter -> int -> unit.
  
  Parameter pp_get_max_indent : formatter -> unit -> int.
  
  Parameter pp_set_max_boxes : formatter -> int -> unit.
  
  Parameter pp_get_max_boxes : formatter -> unit -> int.
  
  Parameter pp_over_max_boxes : formatter -> unit -> bool.
  
  Parameter pp_open_tbox : formatter -> unit -> unit.
  
  Parameter pp_close_tbox : formatter -> unit -> unit.
  
  Parameter pp_set_tab : formatter -> unit -> unit.
  
  Parameter pp_print_tab : formatter -> unit -> unit.
  
  Parameter pp_print_tbreak : formatter -> int -> int -> unit.
  
  Parameter pp_set_ellipsis_text : formatter -> string -> unit.
  
  Parameter pp_get_ellipsis_text : formatter -> unit -> string.
  
  Parameter pp_print_list : forall {a : Set},
    option (formatter -> unit -> unit) -> (formatter -> a -> unit) ->
    formatter -> list a -> unit.
  
  Parameter pp_print_text : formatter -> string -> unit.
  
  Parameter pp_print_option : forall {a : Set},
    option (formatter -> unit -> unit) -> (formatter -> a -> unit) ->
    formatter -> option a -> unit.
  
  Parameter pp_print_result : forall {a e : Set},
    (formatter -> a -> unit) -> (formatter -> e -> unit) -> formatter ->
    Pervasives.result a e -> unit.
  
  Parameter fprintf : forall {a : Set},
    formatter -> Pervasives.format a formatter unit -> a.
  
  Parameter sprintf : forall {a : Set}, Pervasives.format a unit string -> a.
  
  Parameter asprintf : forall {a : Set},
    Pervasives.format4 a formatter unit string -> a.
  
  Parameter dprintf : forall {a : Set},
    Pervasives.format4 a formatter unit (formatter -> unit) -> a.
  
  Parameter ifprintf : forall {a : Set},
    formatter -> Pervasives.format a formatter unit -> a.
  
  Parameter kfprintf : forall {a b : Set},
    (formatter -> a) -> formatter -> Pervasives.format4 b formatter unit a -> b.
  
  Parameter kdprintf : forall {a b : Set},
    ((formatter -> unit) -> a) -> Pervasives.format4 b formatter unit a -> b.
  
  Parameter ikfprintf : forall {a b : Set},
    (formatter -> a) -> formatter -> Pervasives.format4 b formatter unit a -> b.
  
  Parameter ksprintf : forall {a b : Set},
    (string -> a) -> Pervasives.format4 b unit string a -> b.
  
  Parameter kasprintf : forall {a b : Set},
    (string -> a) -> Pervasives.format4 b formatter unit a -> b.
End Format.

Module Logging.
  Inductive level : Set :=
  | Debug : level
  | Info : level
  | Notice : level
  | Warning : level
  | Error : level
  | Fatal : level.
  
  Parameter log : forall {a : Set},
    level -> Pervasives.format4 a Format.formatter unit unit -> a.
  
  Parameter log_string : level -> string -> unit.
End Logging.

Module Hex.
  Inductive t : Set :=
  | Hex : string -> t.
  
  Parameter of_char : ascii -> ascii * ascii.
  
  Parameter to_char : ascii -> ascii -> option ascii.
  
  Parameter of_string : option (list ascii) -> string -> t.
  
  Parameter to_string : t -> option string.
  
  Parameter of_bytes : option (list ascii) -> bytes -> t.
  
  Parameter to_bytes : t -> option bytes.
  
  Parameter hexdump_s : option bool -> option bool -> t -> string.
  
  Parameter pp : Format.formatter -> t -> unit.
  
  Parameter show : t -> string.
End Hex.

Module Z.
  Parameter t : Set.
  
  Parameter zero : t.
  
  Parameter one : t.
  
  Parameter minus_one : t.
  
  Parameter of_int : int -> t.
  
  Parameter of_int32 : int32 -> t.
  
  Parameter of_int64 : int64 -> t.
  
  Parameter of_string : string -> t.
  
  Parameter of_substring : string -> int -> int -> t.
  
  Parameter of_string_base : int -> string -> t.
  
  Parameter of_substring_base : int -> string -> int -> int -> t.
  
  Parameter succ : t -> t.
  
  Parameter pred : t -> t.
  
  Parameter abs : t -> t.
  
  Parameter neg : t -> t.
  
  Parameter add : t -> t -> t.
  
  Parameter sub : t -> t -> t.
  
  Parameter mul : t -> t -> t.
  
  Parameter div : t -> t -> t.
  
  Parameter rem : t -> t -> t.
  
  Parameter div_rem : t -> t -> t * t.
  
  Parameter cdiv : t -> t -> t.
  
  Parameter fdiv : t -> t -> t.
  
  Parameter ediv_rem : t -> t -> t * t.
  
  Parameter ediv : t -> t -> t.
  
  Parameter erem : t -> t -> t.
  
  Parameter divexact : t -> t -> t.
  
  Parameter divisible : t -> t -> bool.
  
  Parameter congruent : t -> t -> t -> bool.
  
  Parameter logand : t -> t -> t.
  
  Parameter logor : t -> t -> t.
  
  Parameter logxor : t -> t -> t.
  
  Parameter lognot : t -> t.
  
  Parameter shift_left : t -> int -> t.
  
  Parameter shift_right : t -> int -> t.
  
  Parameter shift_right_trunc : t -> int -> t.
  
  Parameter numbits : t -> int.
  
  Parameter trailing_zeros : t -> int.
  
  Parameter testbit : t -> int -> bool.
  
  Parameter popcount : t -> int.
  
  Parameter hamdist : t -> t -> int.
  
  Parameter to_int : t -> int.
  
  Parameter to_int32 : t -> int32.
  
  Parameter to_int64 : t -> int64.
  
  Parameter to_string : t -> string.
  
  Parameter format : string -> t -> string.
  
  Parameter fits_int : t -> bool.
  
  Parameter fits_int32 : t -> bool.
  
  Parameter fits_int64 : t -> bool.
  
  Parameter pp_print : Format.formatter -> t -> unit.
  
  Parameter compare : t -> t -> int.
  
  Parameter equal : t -> t -> bool.
  
  Parameter leq : t -> t -> bool.
  
  Parameter geq : t -> t -> bool.
  
  Parameter lt : t -> t -> bool.
  
  Parameter gt : t -> t -> bool.
  
  Parameter sign : t -> int.
  
  Parameter min : t -> t -> t.
  
  Parameter max : t -> t -> t.
  
  Parameter is_even : t -> bool.
  
  Parameter is_odd : t -> bool.
  
  Parameter pow : t -> int -> t.
  
  Parameter sqrt : t -> t.
  
  Parameter sqrt_rem : t -> t * t.
  
  Parameter root_value : t -> int -> t.
  
  Parameter rootrem : t -> int -> t * t.
  
  Parameter perfect_power : t -> bool.
  
  Parameter perfect_square : t -> bool.
  
  Parameter log2 : t -> int.
  
  Parameter log2up : t -> int.
  
  Parameter size_value : t -> int.
  
  Parameter extract : t -> int -> int -> t.
  
  Parameter signed_extract : t -> int -> int -> t.
  
  Parameter to_bits : t -> string.
  
  Parameter of_bits : string -> t.
End Z.

Module Lwt.
  Parameter t : forall (a : Set), Set.
  
  Parameter _return : forall {a : Set}, a -> t a.
  
  Parameter bind : forall {a b : Set}, t a -> (a -> t b) -> t b.
  
  Parameter map : forall {a b : Set}, (a -> b) -> t a -> t b.
  
  Parameter return_unit : t unit.
  
  Parameter return_none : forall {A : Set}, t (option A).
  
  Parameter return_nil : forall {A : Set}, t (list A).
  
  Parameter return_true : t bool.
  
  Parameter return_false : t bool.
End Lwt.

Module Compare.
  Module COMPARABLE.
    Record signature {t : Set} : Set := {
      t := t;
      compare : t -> t -> int;
    }.
  End COMPARABLE.
  Definition COMPARABLE := @COMPARABLE.signature.
  Arguments COMPARABLE {_}.
  
  Module S.
    Record signature {t : Set} : Set := {
      t := t;
      op_eq : t -> t -> bool;
      op_ltgt : t -> t -> bool;
      op_lt : t -> t -> bool;
      op_lteq : t -> t -> bool;
      op_gteq : t -> t -> bool;
      op_gt : t -> t -> bool;
      compare : t -> t -> int;
      equal : t -> t -> bool;
      max : t -> t -> t;
      min : t -> t -> t;
    }.
  End S.
  Definition S := @S.signature.
  Arguments S {_}.
  
  Parameter Make :
    forall {P_t : Set},
    forall (P : COMPARABLE (t := P_t)), S (t := P.(COMPARABLE.t)).
  
  Parameter Char : S (t := ascii).
  
  Parameter Bool : S (t := bool).
  
  Module Int.
    Definition t : Set := int.
    
    Parameter op_eq : int -> int -> bool.
    
    Parameter op_ltgt : int -> int -> bool.
    
    Parameter op_lt : int -> int -> bool.
    
    Parameter op_gt : int -> int -> bool.
    
    Parameter op_lteq : int -> int -> bool.
    
    Parameter op_gteq : int -> int -> bool.
    
    Parameter compare : int -> int -> int.
    
    Parameter max : int -> int -> int.
    
    Parameter min : int -> int -> int.
    
    Parameter equal : int -> int -> bool.
  End Int.
  
  Parameter Int32 : S (t := int32).
  
  Parameter Uint32 : S (t := int32).
  
  Parameter Int64 : S (t := int64).
  
  Parameter Uint64 : S (t := int64).
  
  Parameter String : S (t := string).
  
  Parameter Bytes : S (t := bytes).
  
  Parameter Z : S (t := Z.t).
  
  Parameter List :
    forall {P_t : Set},
    forall (P : COMPARABLE (t := P_t)), S (t := list P.(COMPARABLE.t)).
  
  Parameter Option :
    forall {P_t : Set},
    forall (P : COMPARABLE (t := P_t)), S (t := option P.(COMPARABLE.t)).
  
  Parameter Result :
    forall {Ok_t Error_t : Set},
    forall (Ok : COMPARABLE (t := Ok_t)),
    forall (Error : COMPARABLE (t := Error_t)),
    S (t := Pervasives.result Ok.(COMPARABLE.t) Error.(COMPARABLE.t)).
  
  Module List_length_with.
    Parameter op_eq : forall {a : Set}, list a -> int -> bool.
    
    Parameter op_ltgt : forall {a : Set}, list a -> int -> bool.
    
    Parameter op_lt : forall {a : Set}, list a -> int -> bool.
    
    Parameter op_lteq : forall {a : Set}, list a -> int -> bool.
    
    Parameter op_gteq : forall {a : Set}, list a -> int -> bool.
    
    Parameter op_gt : forall {a : Set}, list a -> int -> bool.
    
    Parameter compare : forall {a : Set}, list a -> int -> int.
    
    Parameter equal : forall {a : Set}, list a -> int -> bool.
  End List_length_with.
  
  Module List_lengths.
    Parameter op_eq : forall {a b : Set}, list a -> list b -> bool.
    
    Parameter op_ltgt : forall {a b : Set}, list a -> list b -> bool.
    
    Parameter op_lt : forall {a b : Set}, list a -> list b -> bool.
    
    Parameter op_lteq : forall {a b : Set}, list a -> list b -> bool.
    
    Parameter op_gteq : forall {a b : Set}, list a -> list b -> bool.
    
    Parameter op_gt : forall {a b : Set}, list a -> list b -> bool.
    
    Parameter compare : forall {a b : Set}, list a -> list b -> int.
    
    Parameter equal : forall {a b : Set}, list a -> list b -> bool.
  End List_lengths.
  
  Parameter or_else : int -> (unit -> int) -> int.
End Compare.

Module Time.
  Parameter t : Set.
  
  Parameter Included_S : Compare.S (t := t).
  
  Definition op_eq : t -> t -> bool := Included_S.(Compare.S.op_eq).
  
  Definition op_ltgt : t -> t -> bool := Included_S.(Compare.S.op_ltgt).
  
  Definition op_lt : t -> t -> bool := Included_S.(Compare.S.op_lt).
  
  Definition op_lteq : t -> t -> bool := Included_S.(Compare.S.op_lteq).
  
  Definition op_gteq : t -> t -> bool := Included_S.(Compare.S.op_gteq).
  
  Definition op_gt : t -> t -> bool := Included_S.(Compare.S.op_gt).
  
  Definition compare : t -> t -> int := Included_S.(Compare.S.compare).
  
  Definition equal : t -> t -> bool := Included_S.(Compare.S.equal).
  
  Definition max : t -> t -> t := Included_S.(Compare.S.max).
  
  Definition min : t -> t -> t := Included_S.(Compare.S.min).
  
  Parameter add : t -> int64 -> t.
  
  Parameter diff_value : t -> t -> int64.
  
  Parameter of_seconds : int64 -> t.
  
  Parameter to_seconds : t -> int64.
  
  Parameter of_notation : string -> option t.
  
  Parameter of_notation_exn : string -> t.
  
  Parameter to_notation : t -> string.
  
  Parameter pp_hum : Format.formatter -> t -> unit.
End Time.

Module TzEndian.
  Parameter get_int32 : bytes -> int -> int32.
  
  Parameter get_int32_string : string -> int -> int32.
  
  Parameter set_int32 : bytes -> int -> int32 -> unit.
  
  Parameter set_int8 : bytes -> int -> int -> unit.
  
  Parameter get_int8 : bytes -> int -> int.
  
  Parameter get_int8_string : string -> int -> int.
  
  Parameter set_int16 : bytes -> int -> int -> unit.
  
  Parameter get_int16 : bytes -> int -> int.
  
  Parameter get_int16_string : string -> int -> int.
  
  Parameter set_int64 : bytes -> int -> int64 -> unit.
  
  Parameter get_int64 : bytes -> int -> int64.
  
  Parameter get_int64_string : string -> int -> int64.
  
  Parameter get_uint8 : bytes -> int -> int.
  
  Parameter get_uint8_string : string -> int -> int.
  
  Parameter set_uint8 : bytes -> int -> int -> unit.
  
  Parameter get_uint16 : bytes -> int -> int.
  
  Parameter get_uint16_string : string -> int -> int.
  
  Parameter set_uint16 : bytes -> int -> int -> unit.
End TzEndian.

Module Bits.
  Parameter numbits : int -> int.
End Bits.

Module Equality_witness.
  Inductive eq : Set :=
  | Refl : eq.
  
  Parameter t : forall (a : Set), Set.
  
  Parameter make : forall {a : Set}, unit -> t a.
  
  Parameter eq_value : forall {a b : Set}, t a -> t b -> option eq.
  
  Parameter hash_value : forall {a : Set}, t a -> int.
End Equality_witness.

Module FallbackArray.
  Parameter t : forall (a : Set), Set.
  
  Parameter make : forall {a : Set}, int -> a -> t a.
  
  Parameter of_list : forall {a b : Set}, b -> (a -> b) -> list a -> t b.
  
  Parameter fallback : forall {a : Set}, t a -> a.
  
  Parameter length : forall {a : Set}, t a -> int.
  
  Parameter get : forall {a : Set}, t a -> int -> a.
  
  Parameter set : forall {a : Set}, t a -> int -> a -> unit.
  
  Parameter iter : forall {a : Set}, (a -> unit) -> t a -> unit.
  
  Parameter map : forall {a b : Set}, (a -> b) -> t a -> t b.
  
  Parameter fold : forall {a b : Set}, (b -> a -> b) -> t a -> b -> b.
  
  Parameter fold_map : forall {a b c : Set},
    (b -> a -> b * c) -> t a -> b -> c -> b * t c.
End FallbackArray.

Module Error_monad.
  Inductive error_category : Set :=
  | Outdated : error_category
  | Permanent : error_category
  | Temporary : error_category
  | Branch : error_category.
  
  Definition _error := extensible_type.
  
  Parameter trace : forall (err : Set), Set.
  
  Definition tzresult (a : Set) : Set := Pervasives.result a (trace _error).
  
  Parameter ok : forall {a trace : Set}, a -> Pervasives.result a trace.
  
  Parameter _return : forall {a trace : Set}, a -> Pervasives.result a trace.
  
  Parameter return_unit : forall {trace : Set}, Pervasives.result unit trace.
  
  Parameter return_none : forall {a trace : Set},
    Pervasives.result (option a) trace.
  
  Parameter return_some : forall {a trace : Set},
    a -> Pervasives.result (option a) trace.
  
  Parameter return_nil : forall {a trace : Set},
    Pervasives.result (list a) trace.
  
  Parameter return_true : forall {trace : Set}, Pervasives.result bool trace.
  
  Parameter return_false : forall {trace : Set}, Pervasives.result bool trace.
  
  Parameter error_value : forall {a err : Set},
    err -> Pervasives.result a (trace err).
  
  Parameter trace_of_error : forall {err : Set}, err -> trace err.
  
  Parameter fail : forall {a err : Set}, err -> Pervasives.result a (trace err).
  
  Parameter op_gtgteq : forall {a b : Set}, a -> (a -> b) -> b.
  
  Parameter op_gtpipeeq : forall {a b : Set}, a -> (a -> b) -> b.
  
  Parameter op_gtgtquestion : forall {a b trace : Set},
    Pervasives.result a trace -> (a -> Pervasives.result b trace) ->
    Pervasives.result b trace.
  
  Parameter op_gtpipequestion : forall {a b trace : Set},
    Pervasives.result a trace -> (a -> b) -> Pervasives.result b trace.
  
  Parameter op_gtgteqquestion : forall {a b trace : Set},
    Pervasives.result a trace -> (a -> Pervasives.result b trace) ->
    Pervasives.result b trace.
  
  Parameter op_gtpipeeqquestion : forall {a b trace : Set},
    Pervasives.result a trace -> (a -> b) -> Pervasives.result b trace.
  
  Parameter op_gtgtquestioneq : forall {a b trace : Set},
    Pervasives.result a trace -> (a -> Pervasives.result b trace) ->
    Pervasives.result b trace.
  
  Parameter op_gtpipequestioneq : forall {a b trace : Set},
    Pervasives.result a trace -> (a -> b) -> Pervasives.result b trace.
  
  Parameter record_trace : forall {a err : Set},
    err -> Pervasives.result a (trace err) -> Pervasives.result a (trace err).
  
  Parameter trace_value : forall {b err : Set},
    err -> Pervasives.result b (trace err) -> Pervasives.result b (trace err).
  
  Parameter record_trace_eval : forall {a err : Set},
    (unit -> err) -> Pervasives.result a (trace err) ->
    Pervasives.result a (trace err).
  
  Parameter trace_eval : forall {b err : Set},
    (unit -> err) -> Pervasives.result b (trace err) ->
    Pervasives.result b (trace err).
  
  Parameter error_unless : forall {err : Set},
    bool -> err -> Pervasives.result unit (trace err).
  
  Parameter error_when : forall {err : Set},
    bool -> err -> Pervasives.result unit (trace err).
  
  Parameter fail_unless : forall {err : Set},
    bool -> err -> Pervasives.result unit (trace err).
  
  Parameter fail_when : forall {err : Set},
    bool -> err -> Pervasives.result unit (trace err).
  
  Parameter unless : forall {trace : Set},
    bool -> (unit -> Pervasives.result unit trace) ->
    Pervasives.result unit trace.
  
  Parameter when_ : forall {trace : Set},
    bool -> (unit -> Pervasives.result unit trace) ->
    Pervasives.result unit trace.
  
  Parameter dont_wait : forall {trace : Set},
    (extensible_type -> unit) -> (trace -> unit) ->
    (unit -> Pervasives.result unit trace) -> unit.
  
  Parameter catch : forall {a : Set},
    option (extensible_type -> bool) -> (unit -> a) -> tzresult a.
  
  Parameter catch_f : forall {a : Set},
    option (extensible_type -> bool) -> (unit -> a) ->
    (extensible_type -> _error) -> tzresult a.
  
  Parameter catch_s : forall {a : Set},
    option (extensible_type -> bool) -> (unit -> a) -> tzresult a.
  
  Parameter join_e : forall {err : Set},
    list (Pervasives.result unit (trace err)) ->
    Pervasives.result unit (trace err).
  
  Parameter all_e : forall {a err : Set},
    list (Pervasives.result a (trace err)) ->
    Pervasives.result (list a) (trace err).
  
  Parameter both_e : forall {a b err : Set},
    Pervasives.result a (trace err) -> Pervasives.result b (trace err) ->
    Pervasives.result (a * b) (trace err).
  
  Parameter shell_tztrace : Set.
  
  Definition shell_tzresult (a : Set) : Set :=
    Pervasives.result a shell_tztrace.
  
  Module Lwt_syntax.
    Parameter _return : forall {a : Set}, a -> a.
    
    Parameter return_none : forall {A : Set}, option A.
    
    Parameter return_nil : forall {A : Set}, list A.
    
    Parameter return_true : bool.
    
    Parameter return_false : bool.
    
    Parameter return_some : forall {a : Set}, a -> option a.
    
    Parameter return_ok : forall {B a : Set}, a -> Pervasives.result a B.
    
    Parameter return_error : forall {B e : Set}, e -> Pervasives.result B e.
    
    Parameter return_ok_unit : forall {e : Set}, Pervasives.result unit e.
    
    Parameter return_ok_true : forall {e : Set}, Pervasives.result bool e.
    
    Parameter return_ok_false : forall {e : Set}, Pervasives.result bool e.
    
    Parameter return_ok_none : forall {a e : Set},
      Pervasives.result (option a) e.
    
    Parameter return_ok_nil : forall {a e : Set}, Pervasives.result (list a) e.
    
    Parameter op_letstar : forall {a b : Set}, a -> (a -> b) -> b.
    
    Parameter op_andstar : forall {a b : Set}, a -> b -> a * b.
    
    Parameter op_letplus : forall {a b : Set}, a -> (a -> b) -> b.
    
    Parameter op_andplus : forall {a b : Set}, a -> b -> a * b.
    
    Parameter join : list unit -> unit.
    
    Parameter all : forall {a : Set}, list a -> list a.
    
    Parameter both : forall {a b : Set}, a -> b -> a * b.
  End Lwt_syntax.
  
  Module Result_syntax.
    Parameter _return : forall {a e : Set}, a -> Pervasives.result a e.
    
    Parameter return_unit : forall {e : Set}, Pervasives.result unit e.
    
    Parameter return_none : forall {a e : Set}, Pervasives.result (option a) e.
    
    Parameter return_some : forall {a e : Set},
      a -> Pervasives.result (option a) e.
    
    Parameter return_nil : forall {a e : Set}, Pervasives.result (list a) e.
    
    Parameter return_true : forall {e : Set}, Pervasives.result bool e.
    
    Parameter return_false : forall {e : Set}, Pervasives.result bool e.
    
    Parameter fail : forall {a e : Set}, e -> Pervasives.result a e.
    
    Parameter op_letstar : forall {a b e : Set},
      Pervasives.result a e -> (a -> Pervasives.result b e) ->
      Pervasives.result b e.
    
    Parameter op_letplus : forall {a b e : Set},
      Pervasives.result a e -> (a -> b) -> Pervasives.result b e.
    
    Parameter join : forall {e : Set},
      list (Pervasives.result unit e) -> Pervasives.result unit (list e).
    
    Parameter all : forall {a e : Set},
      list (Pervasives.result a e) -> Pervasives.result (list a) (list e).
    
    Parameter both : forall {a b e : Set},
      Pervasives.result a e -> Pervasives.result b e ->
      Pervasives.result (a * b) (list e).
  End Result_syntax.
  
  Module Lwt_result_syntax.
    Parameter _return : forall {a e : Set}, a -> Pervasives.result a e.
    
    Parameter return_unit : forall {e : Set}, Pervasives.result unit e.
    
    Parameter return_none : forall {a e : Set}, Pervasives.result (option a) e.
    
    Parameter return_some : forall {a e : Set},
      a -> Pervasives.result (option a) e.
    
    Parameter return_nil : forall {a e : Set}, Pervasives.result (list a) e.
    
    Parameter return_true : forall {e : Set}, Pervasives.result bool e.
    
    Parameter return_false : forall {e : Set}, Pervasives.result bool e.
    
    Parameter fail : forall {a e : Set}, e -> Pervasives.result a e.
    
    Parameter op_letstar : forall {a b e : Set},
      Pervasives.result a e -> (a -> Pervasives.result b e) ->
      Pervasives.result b e.
    
    Parameter op_letplus : forall {a b e : Set},
      Pervasives.result a e -> (a -> b) -> Pervasives.result b e.
    
    Parameter lwt_map_error : forall {a e f : Set},
      (e -> f) -> Pervasives.result a e -> Pervasives.result a f.
    
    Parameter op_letstarexclamation : forall {a b : Set}, a -> (a -> b) -> b.
    
    Parameter op_letstarquestion : forall {a b e : Set},
      Pervasives.result a e -> (a -> Pervasives.result b e) ->
      Pervasives.result b e.
    
    Parameter join : forall {e : Set},
      list (Pervasives.result unit e) -> Pervasives.result unit (list e).
    
    Parameter all : forall {a e : Set},
      list (Pervasives.result a e) -> Pervasives.result (list a) (list e).
    
    Parameter both : forall {a b e : Set},
      Pervasives.result a e -> Pervasives.result b e ->
      Pervasives.result (a * b) (list e).
  End Lwt_result_syntax.
  
  Module Tzresult_syntax.
    Parameter _return : forall {_error a : Set},
      a -> Pervasives.result a _error.
    
    Parameter return_unit : forall {_error : Set},
      Pervasives.result unit _error.
    
    Parameter return_none : forall {_error a : Set},
      Pervasives.result (option a) _error.
    
    Parameter return_some : forall {_error a : Set},
      a -> Pervasives.result (option a) _error.
    
    Parameter return_nil : forall {_error a : Set},
      Pervasives.result (list a) _error.
    
    Parameter return_true : forall {_error : Set},
      Pervasives.result bool _error.
    
    Parameter return_false : forall {_error : Set},
      Pervasives.result bool _error.
    
    Parameter fail : forall {_error a : Set},
      _error -> Pervasives.result a (trace _error).
    
    Parameter op_letstar : forall {a b e : Set},
      Pervasives.result a e -> (a -> Pervasives.result b e) ->
      Pervasives.result b e.
    
    Parameter op_andstar : forall {a b e : Set},
      Pervasives.result a (trace e) -> Pervasives.result b (trace e) ->
      Pervasives.result (a * b) (trace e).
    
    Parameter op_letplus : forall {a b e : Set},
      Pervasives.result a e -> (a -> b) -> Pervasives.result b e.
    
    Parameter op_andplus : forall {a b e : Set},
      Pervasives.result a (trace e) -> Pervasives.result b (trace e) ->
      Pervasives.result (a * b) (trace e).
    
    Parameter join : forall {_error : Set},
      list (Pervasives.result unit (trace _error)) ->
      Pervasives.result unit (trace _error).
    
    Parameter all : forall {_error a : Set},
      list (Pervasives.result a (trace _error)) ->
      Pervasives.result (list a) (trace _error).
    
    Parameter both : forall {_error a b : Set},
      Pervasives.result a (trace _error) ->
      Pervasives.result b (trace _error) ->
      Pervasives.result (a * b) (trace _error).
  End Tzresult_syntax.
  
  Module Lwt_tzresult_syntax.
    Parameter _return : forall {_error a : Set},
      a -> Pervasives.result a _error.
    
    Parameter return_unit : forall {_error : Set},
      Pervasives.result unit _error.
    
    Parameter return_none : forall {_error a : Set},
      Pervasives.result (option a) _error.
    
    Parameter return_some : forall {_error a : Set},
      a -> Pervasives.result (option a) _error.
    
    Parameter return_nil : forall {_error a : Set},
      Pervasives.result (list a) _error.
    
    Parameter return_true : forall {_error : Set},
      Pervasives.result bool _error.
    
    Parameter return_false : forall {_error : Set},
      Pervasives.result bool _error.
    
    Parameter fail : forall {_error a : Set},
      _error -> Pervasives.result a (trace _error).
    
    Parameter op_letstar : forall {a b e : Set},
      Pervasives.result a e -> (a -> Pervasives.result b e) ->
      Pervasives.result b e.
    
    Parameter op_andstar : forall {a b e : Set},
      Pervasives.result a (trace e) -> Pervasives.result b (trace e) ->
      Pervasives.result (a * b) (trace e).
    
    Parameter op_letplus : forall {a b e : Set},
      Pervasives.result a e -> (a -> b) -> Pervasives.result b e.
    
    Parameter op_andplus : forall {a b e : Set},
      Pervasives.result a (trace e) -> Pervasives.result b (trace e) ->
      Pervasives.result (a * b) (trace e).
    
    Parameter op_letstarexclamation : forall {a b : Set}, a -> (a -> b) -> b.
    
    Parameter op_letstarquestion : forall {a b e : Set},
      Pervasives.result a e -> (a -> Pervasives.result b e) ->
      Pervasives.result b e.
    
    Parameter join : forall {_error : Set},
      list (Pervasives.result unit (trace _error)) ->
      Pervasives.result unit (trace _error).
    
    Parameter all : forall {_error a : Set},
      list (Pervasives.result a (trace _error)) ->
      Pervasives.result (list a) (trace _error).
    
    Parameter both : forall {_error a b : Set},
      Pervasives.result a (trace _error) ->
      Pervasives.result b (trace _error) ->
      Pervasives.result (a * b) (trace _error).
  End Lwt_tzresult_syntax.
End Error_monad.

Module Seq.
  Reserved Notation "'t".
  
  Inductive node (a : Set) : Set :=
  | Nil : node a
  | Cons : a -> 't a -> node a
  
  where "'t" := (fun (t_a : Set) => unit -> node t_a).
  
  Definition t := 't.
  
  Arguments Nil {_}.
  Arguments Cons {_}.
  
  Parameter empty : forall {a : Set}, t a.
  
  Parameter _return : forall {a : Set}, a -> t a.
  
  Parameter cons_value : forall {a : Set}, a -> t a -> t a.
  
  Parameter append : forall {a : Set}, t a -> t a -> t a.
  
  Parameter map : forall {a b : Set}, (a -> b) -> t a -> t b.
  
  Parameter filter : forall {a : Set}, (a -> bool) -> t a -> t a.
  
  Parameter filter_map : forall {a b : Set}, (a -> option b) -> t a -> t b.
  
  Parameter flat_map : forall {a b : Set}, (a -> t b) -> t a -> t b.
  
  Parameter fold_left : forall {a b : Set}, (a -> b -> a) -> a -> t b -> a.
  
  Parameter iter : forall {a : Set}, (a -> unit) -> t a -> unit.
  
  Parameter unfold : forall {a b : Set}, (b -> option (a * b)) -> b -> t a.
  
  Parameter first : forall {a : Set}, t a -> option a.
  
  Parameter fold_left_e : forall {a b trace : Set},
    (a -> b -> Pervasives.result a trace) -> a -> t b ->
    Pervasives.result a trace.
  
  Parameter fold_left_s : forall {a b : Set}, (a -> b -> a) -> a -> t b -> a.
  
  Parameter fold_left_es : forall {a b trace : Set},
    (a -> b -> Pervasives.result a trace) -> a -> t b ->
    Pervasives.result a trace.
  
  Parameter iter_e : forall {a trace : Set},
    (a -> Pervasives.result unit trace) -> t a -> Pervasives.result unit trace.
  
  Parameter iter_s : forall {a : Set}, (a -> unit) -> t a -> unit.
  
  Parameter iter_es : forall {a trace : Set},
    (a -> Pervasives.result unit trace) -> t a -> Pervasives.result unit trace.
  
  Parameter iter_p : forall {a : Set}, (a -> unit) -> t a -> unit.
End Seq.

Module List.
  Definition t (a : Set) : Set := list a.
  
  Parameter nil : forall {a : Set}, list a.
  
  Parameter nil_e : forall {a trace : Set}, Pervasives.result (list a) trace.
  
  Parameter nil_s : forall {a : Set}, list a.
  
  Parameter nil_es : forall {a trace : Set}, Pervasives.result (list a) trace.
  
  Parameter cons_value : forall {a : Set}, a -> list a -> list a.
  
  Parameter hd : forall {a : Set}, list a -> option a.
  
  Parameter tl : forall {a : Set}, list a -> option (list a).
  
  Parameter nth : forall {a : Set}, list a -> int -> option a.
  
  Parameter nth_opt : forall {a : Set}, list a -> int -> option a.
  
  Parameter last : forall {a : Set}, a -> list a -> a.
  
  Parameter last_opt : forall {a : Set}, list a -> option a.
  
  Parameter find : forall {a : Set}, (a -> bool) -> list a -> option a.
  
  Parameter find_opt : forall {a : Set}, (a -> bool) -> list a -> option a.
  
  Parameter find_map : forall {a b : Set},
    (a -> option b) -> list a -> option b.
  
  Parameter mem : forall {a : Set}, (a -> a -> bool) -> a -> list a -> bool.
  
  Parameter assoc : forall {a b : Set},
    (a -> a -> bool) -> a -> list (a * b) -> option b.
  
  Parameter assoc_opt : forall {a b : Set},
    (a -> a -> bool) -> a -> list (a * b) -> option b.
  
  Parameter assq : forall {a b : Set}, a -> list (a * b) -> option b.
  
  Parameter assq_opt : forall {a b : Set}, a -> list (a * b) -> option b.
  
  Parameter mem_assoc : forall {a b : Set},
    (a -> a -> bool) -> a -> list (a * b) -> bool.
  
  Parameter mem_assq : forall {a b : Set}, a -> list (a * b) -> bool.
  
  Parameter remove_assoc : forall {a b : Set},
    (a -> a -> bool) -> a -> list (a * b) -> list (a * b).
  
  Parameter remove_assq : forall {a b : Set}, a -> list (a * b) -> list (a * b).
  
  Parameter init_value : forall {a trace : Set},
    trace -> int -> (int -> a) -> Pervasives.result (list a) trace.
  
  Parameter length : forall {a : Set}, list a -> int.
  
  Parameter rev : forall {a : Set}, list a -> list a.
  
  Parameter concat : forall {a : Set}, list (list a) -> list a.
  
  Parameter append : forall {a : Set}, list a -> list a -> list a.
  
  Parameter rev_append : forall {a : Set}, list a -> list a -> list a.
  
  Parameter flatten : forall {a : Set}, list (list a) -> list a.
  
  Parameter combine : forall {a b trace : Set},
    trace -> list a -> list b -> Pervasives.result (list (a * b)) trace.
  
  Parameter rev_combine : forall {a b trace : Set},
    trace -> list a -> list b -> Pervasives.result (list (a * b)) trace.
  
  Parameter split : forall {a b : Set}, list (a * b) -> list a * list b.
  
  Parameter iter2 : forall {a b trace : Set},
    trace -> (a -> b -> unit) -> list a -> list b ->
    Pervasives.result unit trace.
  
  Parameter map2 : forall {a b c trace : Set},
    trace -> (a -> b -> c) -> list a -> list b ->
    Pervasives.result (list c) trace.
  
  Parameter rev_map2 : forall {a b c trace : Set},
    trace -> (a -> b -> c) -> list a -> list b ->
    Pervasives.result (list c) trace.
  
  Parameter fold_left2 : forall {a b c trace : Set},
    trace -> (a -> b -> c -> a) -> a -> list b -> list c ->
    Pervasives.result a trace.
  
  Parameter fold_right2 : forall {a b c trace : Set},
    trace -> (a -> b -> c -> c) -> list a -> list b -> c ->
    Pervasives.result c trace.
  
  Parameter for_all2 : forall {a b trace : Set},
    trace -> (a -> b -> bool) -> list a -> list b ->
    Pervasives.result bool trace.
  
  Parameter _exists2 : forall {a b trace : Set},
    trace -> (a -> b -> bool) -> list a -> list b ->
    Pervasives.result bool trace.
  
  Parameter init_e : forall {a trace : Set},
    trace -> int -> (int -> Pervasives.result a trace) ->
    Pervasives.result (list a) trace.
  
  Parameter init_s : forall {a trace : Set},
    trace -> int -> (int -> a) -> Pervasives.result (list a) trace.
  
  Parameter init_es : forall {a trace : Set},
    trace -> int -> (int -> Pervasives.result a trace) ->
    Pervasives.result (list a) trace.
  
  Parameter init_p : forall {a trace : Set},
    trace -> int -> (int -> a) -> Pervasives.result (list a) trace.
  
  Parameter find_e : forall {a trace : Set},
    (a -> Pervasives.result bool trace) -> list a ->
    Pervasives.result (option a) trace.
  
  Parameter find_s : forall {a : Set}, (a -> bool) -> list a -> option a.
  
  Parameter find_es : forall {a trace : Set},
    (a -> Pervasives.result bool trace) -> list a ->
    Pervasives.result (option a) trace.
  
  Parameter find_map_e : forall {a b trace : Set},
    (a -> Pervasives.result (option b) trace) -> list a ->
    Pervasives.result (option b) trace.
  
  Parameter find_map_s : forall {a b : Set},
    (a -> option b) -> list a -> option b.
  
  Parameter find_map_es : forall {a b trace : Set},
    (a -> Pervasives.result (option b) trace) -> list a ->
    Pervasives.result (option b) trace.
  
  Parameter filter : forall {a : Set}, (a -> bool) -> list a -> list a.
  
  Parameter filteri : forall {a : Set}, (int -> a -> bool) -> list a -> list a.
  
  Parameter find_all : forall {a : Set}, (a -> bool) -> list a -> list a.
  
  Parameter rev_filter : forall {a : Set}, (a -> bool) -> list a -> list a.
  
  Parameter rev_filteri : forall {a : Set},
    (int -> a -> bool) -> list a -> list a.
  
  Parameter rev_filter_some : forall {a : Set}, list (option a) -> list a.
  
  Parameter filter_some : forall {a : Set}, list (option a) -> list a.
  
  Parameter rev_filter_ok : forall {a b : Set},
    list (Pervasives.result a b) -> list a.
  
  Parameter filter_ok : forall {a b : Set},
    list (Pervasives.result a b) -> list a.
  
  Parameter rev_filter_error : forall {a b : Set},
    list (Pervasives.result a b) -> list b.
  
  Parameter filter_error : forall {a b : Set},
    list (Pervasives.result a b) -> list b.
  
  Parameter rev_filter_left : forall {a b : Set}, list (Either.t a b) -> list a.
  
  Parameter filter_left : forall {a b : Set}, list (Either.t a b) -> list a.
  
  Parameter rev_filter_right : forall {a b : Set},
    list (Either.t a b) -> list b.
  
  Parameter filter_right : forall {a b : Set}, list (Either.t a b) -> list b.
  
  Parameter rev_filter_e : forall {a trace : Set},
    (a -> Pervasives.result bool trace) -> list a ->
    Pervasives.result (list a) trace.
  
  Parameter filter_e : forall {a trace : Set},
    (a -> Pervasives.result bool trace) -> list a ->
    Pervasives.result (list a) trace.
  
  Parameter rev_filter_s : forall {a : Set}, (a -> bool) -> list a -> list a.
  
  Parameter filter_s : forall {a : Set}, (a -> bool) -> list a -> list a.
  
  Parameter rev_filter_es : forall {a trace : Set},
    (a -> Pervasives.result bool trace) -> list a ->
    Pervasives.result (list a) trace.
  
  Parameter filter_es : forall {a trace : Set},
    (a -> Pervasives.result bool trace) -> list a ->
    Pervasives.result (list a) trace.
  
  Parameter rev_filteri_e : forall {a trace : Set},
    (int -> a -> Pervasives.result bool trace) -> list a ->
    Pervasives.result (list a) trace.
  
  Parameter filteri_e : forall {a trace : Set},
    (int -> a -> Pervasives.result bool trace) -> list a ->
    Pervasives.result (list a) trace.
  
  Parameter rev_filteri_s : forall {a : Set},
    (int -> a -> bool) -> list a -> list a.
  
  Parameter filteri_s : forall {a : Set},
    (int -> a -> bool) -> list a -> list a.
  
  Parameter rev_filteri_es : forall {a trace : Set},
    (int -> a -> Pervasives.result bool trace) -> list a ->
    Pervasives.result (list a) trace.
  
  Parameter filteri_es : forall {a trace : Set},
    (int -> a -> Pervasives.result bool trace) -> list a ->
    Pervasives.result (list a) trace.
  
  Parameter rev_partition : forall {a : Set},
    (a -> bool) -> list a -> list a * list a.
  
  Parameter partition : forall {a : Set},
    (a -> bool) -> list a -> list a * list a.
  
  Parameter rev_partition_map : forall {a b c : Set},
    (a -> Either.t b c) -> list a -> list b * list c.
  
  Parameter partition_map : forall {a b c : Set},
    (a -> Either.t b c) -> list a -> list b * list c.
  
  Parameter rev_partition_result : forall {a b : Set},
    list (Pervasives.result a b) -> list a * list b.
  
  Parameter partition_result : forall {a b : Set},
    list (Pervasives.result a b) -> list a * list b.
  
  Parameter rev_partition_either : forall {a b : Set},
    list (Either.t a b) -> list a * list b.
  
  Parameter partition_either : forall {a b : Set},
    list (Either.t a b) -> list a * list b.
  
  Parameter rev_partition_e : forall {a trace : Set},
    (a -> Pervasives.result bool trace) -> list a ->
    Pervasives.result (list a * list a) trace.
  
  Parameter partition_e : forall {a trace : Set},
    (a -> Pervasives.result bool trace) -> list a ->
    Pervasives.result (list a * list a) trace.
  
  Parameter rev_partition_s : forall {a : Set},
    (a -> bool) -> list a -> list a * list a.
  
  Parameter partition_s : forall {a : Set},
    (a -> bool) -> list a -> list a * list a.
  
  Parameter rev_partition_es : forall {a trace : Set},
    (a -> Pervasives.result bool trace) -> list a ->
    Pervasives.result (list a * list a) trace.
  
  Parameter partition_es : forall {a trace : Set},
    (a -> Pervasives.result bool trace) -> list a ->
    Pervasives.result (list a * list a) trace.
  
  Parameter partition_p : forall {a : Set},
    (a -> bool) -> list a -> list a * list a.
  
  Parameter rev_partition_map_e : forall {a b c trace : Set},
    (a -> Pervasives.result (Either.t b c) trace) -> list a ->
    Pervasives.result (list b * list c) trace.
  
  Parameter partition_map_e : forall {a b c trace : Set},
    (a -> Pervasives.result (Either.t b c) trace) -> list a ->
    Pervasives.result (list b * list c) trace.
  
  Parameter rev_partition_map_s : forall {a b c : Set},
    (a -> Either.t b c) -> list a -> list b * list c.
  
  Parameter partition_map_s : forall {a b c : Set},
    (a -> Either.t b c) -> list a -> list b * list c.
  
  Parameter rev_partition_map_es : forall {a b c trace : Set},
    (a -> Pervasives.result (Either.t b c) trace) -> list a ->
    Pervasives.result (list b * list c) trace.
  
  Parameter partition_map_es : forall {a b c trace : Set},
    (a -> Pervasives.result (Either.t b c) trace) -> list a ->
    Pervasives.result (list b * list c) trace.
  
  Parameter iter : forall {a : Set}, (a -> unit) -> list a -> unit.
  
  Parameter iter_e : forall {a trace : Set},
    (a -> Pervasives.result unit trace) -> list a ->
    Pervasives.result unit trace.
  
  Parameter iter_s : forall {a : Set}, (a -> unit) -> list a -> unit.
  
  Parameter iter_es : forall {a trace : Set},
    (a -> Pervasives.result unit trace) -> list a ->
    Pervasives.result unit trace.
  
  Parameter iter_p : forall {a : Set}, (a -> unit) -> list a -> unit.
  
  Parameter iteri : forall {a : Set}, (int -> a -> unit) -> list a -> unit.
  
  Parameter iteri_e : forall {a trace : Set},
    (int -> a -> Pervasives.result unit trace) -> list a ->
    Pervasives.result unit trace.
  
  Parameter iteri_s : forall {a : Set}, (int -> a -> unit) -> list a -> unit.
  
  Parameter iteri_es : forall {a trace : Set},
    (int -> a -> Pervasives.result unit trace) -> list a ->
    Pervasives.result unit trace.
  
  Parameter iteri_p : forall {a : Set}, (int -> a -> unit) -> list a -> unit.
  
  Parameter map : forall {a b : Set}, (a -> b) -> list a -> list b.
  
  Parameter map_e : forall {a b trace : Set},
    (a -> Pervasives.result b trace) -> list a ->
    Pervasives.result (list b) trace.
  
  Parameter map_s : forall {a b : Set}, (a -> b) -> list a -> list b.
  
  Parameter map_es : forall {a b trace : Set},
    (a -> Pervasives.result b trace) -> list a ->
    Pervasives.result (list b) trace.
  
  Parameter map_p : forall {a b : Set}, (a -> b) -> list a -> list b.
  
  Parameter mapi : forall {a b : Set}, (int -> a -> b) -> list a -> list b.
  
  Parameter mapi_e : forall {a b trace : Set},
    (int -> a -> Pervasives.result b trace) -> list a ->
    Pervasives.result (list b) trace.
  
  Parameter mapi_s : forall {a b : Set}, (int -> a -> b) -> list a -> list b.
  
  Parameter mapi_es : forall {a b trace : Set},
    (int -> a -> Pervasives.result b trace) -> list a ->
    Pervasives.result (list b) trace.
  
  Parameter mapi_p : forall {a b : Set}, (int -> a -> b) -> list a -> list b.
  
  Parameter rev_map : forall {a b : Set}, (a -> b) -> list a -> list b.
  
  Parameter rev_mapi : forall {a b : Set}, (int -> a -> b) -> list a -> list b.
  
  Parameter rev_map_e : forall {a b trace : Set},
    (a -> Pervasives.result b trace) -> list a ->
    Pervasives.result (list b) trace.
  
  Parameter rev_map_s : forall {a b : Set}, (a -> b) -> list a -> list b.
  
  Parameter rev_map_es : forall {a b trace : Set},
    (a -> Pervasives.result b trace) -> list a ->
    Pervasives.result (list b) trace.
  
  Parameter rev_map_p : forall {a b : Set}, (a -> b) -> list a -> list b.
  
  Parameter rev_mapi_e : forall {a b trace : Set},
    (int -> a -> Pervasives.result b trace) -> list a ->
    Pervasives.result (list b) trace.
  
  Parameter rev_mapi_s : forall {a b : Set},
    (int -> a -> b) -> list a -> list b.
  
  Parameter rev_mapi_es : forall {a b trace : Set},
    (int -> a -> Pervasives.result b trace) -> list a ->
    Pervasives.result (list b) trace.
  
  Parameter rev_mapi_p : forall {a b : Set},
    (int -> a -> b) -> list a -> list b.
  
  Parameter rev_filter_map : forall {a b : Set},
    (a -> option b) -> list a -> list b.
  
  Parameter rev_filter_map_e : forall {a b trace : Set},
    (a -> Pervasives.result (option b) trace) -> list a ->
    Pervasives.result (list b) trace.
  
  Parameter filter_map_e : forall {a b trace : Set},
    (a -> Pervasives.result (option b) trace) -> list a ->
    Pervasives.result (list b) trace.
  
  Parameter rev_filter_map_s : forall {a b : Set},
    (a -> option b) -> list a -> list b.
  
  Parameter filter_map : forall {a b : Set},
    (a -> option b) -> list a -> list b.
  
  Parameter filter_map_s : forall {a b : Set},
    (a -> option b) -> list a -> list b.
  
  Parameter rev_filter_map_es : forall {a b trace : Set},
    (a -> Pervasives.result (option b) trace) -> list a ->
    Pervasives.result (list b) trace.
  
  Parameter filter_map_es : forall {a b trace : Set},
    (a -> Pervasives.result (option b) trace) -> list a ->
    Pervasives.result (list b) trace.
  
  Parameter filter_map_p : forall {a b : Set},
    (a -> option b) -> list a -> list b.
  
  Parameter concat_map : forall {a b : Set}, (a -> list b) -> list a -> list b.
  
  Parameter concat_map_s : forall {a b : Set},
    (a -> list b) -> list a -> list b.
  
  Parameter concat_map_e : forall {_error a b : Set},
    (a -> Pervasives.result (list b) _error) -> list a ->
    Pervasives.result (list b) _error.
  
  Parameter concat_map_es : forall {_error a b : Set},
    (a -> Pervasives.result (list b) _error) -> list a ->
    Pervasives.result (list b) _error.
  
  Parameter concat_map_p : forall {a b : Set},
    (a -> list b) -> list a -> list b.
  
  Parameter fold_left : forall {a b : Set}, (a -> b -> a) -> a -> list b -> a.
  
  Parameter fold_left_e : forall {a b trace : Set},
    (a -> b -> Pervasives.result a trace) -> a -> list b ->
    Pervasives.result a trace.
  
  Parameter fold_left_s : forall {a b : Set}, (a -> b -> a) -> a -> list b -> a.
  
  Parameter fold_left_es : forall {a b trace : Set},
    (a -> b -> Pervasives.result a trace) -> a -> list b ->
    Pervasives.result a trace.
  
  Parameter fold_left_map : forall {a b c : Set},
    (a -> b -> a * c) -> a -> list b -> a * list c.
  
  Parameter fold_left_map_e : forall {a b c trace : Set},
    (a -> b -> Pervasives.result (a * c) trace) -> a -> list b ->
    Pervasives.result (a * list c) trace.
  
  Parameter fold_left_map_s : forall {a b c : Set},
    (a -> b -> a * c) -> a -> list b -> a * list c.
  
  Parameter fold_left_map_es : forall {a b c trace : Set},
    (a -> b -> Pervasives.result (a * c) trace) -> a -> list b ->
    Pervasives.result (a * list c) trace.
  
  Parameter fold_left_i : forall {a b : Set},
    (int -> a -> b -> a) -> a -> list b -> a.
  
  Parameter fold_left_i_e : forall {a b trace : Set},
    (int -> a -> b -> Pervasives.result a trace) -> a -> list b ->
    Pervasives.result a trace.
  
  Parameter fold_left_i_s : forall {a b : Set},
    (int -> a -> b -> a) -> a -> list b -> a.
  
  Parameter fold_left_i_es : forall {a b trace : Set},
    (int -> a -> b -> Pervasives.result a trace) -> a -> list b ->
    Pervasives.result a trace.
  
  Parameter fold_right : forall {a b : Set}, (a -> b -> b) -> list a -> b -> b.
  
  Parameter fold_right_e : forall {a b trace : Set},
    (a -> b -> Pervasives.result b trace) -> list a -> b ->
    Pervasives.result b trace.
  
  Parameter fold_right_s : forall {a b : Set},
    (a -> b -> b) -> list a -> b -> b.
  
  Parameter fold_right_es : forall {a b trace : Set},
    (a -> b -> Pervasives.result b trace) -> list a -> b ->
    Pervasives.result b trace.
  
  Parameter iter2_e : forall {a b trace : Set},
    trace -> (a -> b -> Pervasives.result unit trace) -> list a -> list b ->
    Pervasives.result unit trace.
  
  Parameter iter2_s : forall {a b trace : Set},
    trace -> (a -> b -> unit) -> list a -> list b ->
    Pervasives.result unit trace.
  
  Parameter iter2_es : forall {a b trace : Set},
    trace -> (a -> b -> Pervasives.result unit trace) -> list a -> list b ->
    Pervasives.result unit trace.
  
  Parameter map2_e : forall {a b c trace : Set},
    trace -> (a -> b -> Pervasives.result c trace) -> list a -> list b ->
    Pervasives.result (list c) trace.
  
  Parameter map2_s : forall {a b c trace : Set},
    trace -> (a -> b -> c) -> list a -> list b ->
    Pervasives.result (list c) trace.
  
  Parameter map2_es : forall {a b c trace : Set},
    trace -> (a -> b -> Pervasives.result c trace) -> list a -> list b ->
    Pervasives.result (list c) trace.
  
  Parameter rev_map2_e : forall {a b c trace : Set},
    trace -> (a -> b -> Pervasives.result c trace) -> list a -> list b ->
    Pervasives.result (list c) trace.
  
  Parameter rev_map2_s : forall {a b c trace : Set},
    trace -> (a -> b -> c) -> list a -> list b ->
    Pervasives.result (list c) trace.
  
  Parameter rev_map2_es : forall {a b c trace : Set},
    trace -> (a -> b -> Pervasives.result c trace) -> list a -> list b ->
    Pervasives.result (list c) trace.
  
  Parameter fold_left2_e : forall {a b c trace : Set},
    trace -> (a -> b -> c -> Pervasives.result a trace) -> a -> list b ->
    list c -> Pervasives.result a trace.
  
  Parameter fold_left2_s : forall {a b c trace : Set},
    trace -> (a -> b -> c -> a) -> a -> list b -> list c ->
    Pervasives.result a trace.
  
  Parameter fold_left2_es : forall {a b c trace : Set},
    trace -> (a -> b -> c -> Pervasives.result a trace) -> a -> list b ->
    list c -> Pervasives.result a trace.
  
  Parameter fold_right2_e : forall {a b c trace : Set},
    trace -> (a -> b -> c -> Pervasives.result c trace) -> list a -> list b ->
    c -> Pervasives.result c trace.
  
  Parameter fold_right2_s : forall {a b c trace : Set},
    trace -> (a -> b -> c -> c) -> list a -> list b -> c ->
    Pervasives.result c trace.
  
  Parameter fold_right2_es : forall {a b c trace : Set},
    trace -> (a -> b -> c -> Pervasives.result c trace) -> list a -> list b ->
    c -> Pervasives.result c trace.
  
  Parameter for_all : forall {a : Set}, (a -> bool) -> list a -> bool.
  
  Parameter for_all_e : forall {a trace : Set},
    (a -> Pervasives.result bool trace) -> list a ->
    Pervasives.result bool trace.
  
  Parameter for_all_s : forall {a : Set}, (a -> bool) -> list a -> bool.
  
  Parameter for_all_es : forall {a trace : Set},
    (a -> Pervasives.result bool trace) -> list a ->
    Pervasives.result bool trace.
  
  Parameter for_all_p : forall {a : Set}, (a -> bool) -> list a -> bool.
  
  Parameter _exists : forall {a : Set}, (a -> bool) -> list a -> bool.
  
  Parameter exists_e : forall {a trace : Set},
    (a -> Pervasives.result bool trace) -> list a ->
    Pervasives.result bool trace.
  
  Parameter exists_s : forall {a : Set}, (a -> bool) -> list a -> bool.
  
  Parameter exists_es : forall {a trace : Set},
    (a -> Pervasives.result bool trace) -> list a ->
    Pervasives.result bool trace.
  
  Parameter exists_p : forall {a : Set}, (a -> bool) -> list a -> bool.
  
  Parameter for_all2_e : forall {a b trace : Set},
    trace -> (a -> b -> Pervasives.result bool trace) -> list a -> list b ->
    Pervasives.result bool trace.
  
  Parameter for_all2_s : forall {a b trace : Set},
    trace -> (a -> b -> bool) -> list a -> list b ->
    Pervasives.result bool trace.
  
  Parameter for_all2_es : forall {a b trace : Set},
    trace -> (a -> b -> Pervasives.result bool trace) -> list a -> list b ->
    Pervasives.result bool trace.
  
  Parameter exists2_e : forall {a b trace : Set},
    trace -> (a -> b -> Pervasives.result bool trace) -> list a -> list b ->
    Pervasives.result bool trace.
  
  Parameter exists2_s : forall {a b trace : Set},
    trace -> (a -> b -> bool) -> list a -> list b ->
    Pervasives.result bool trace.
  
  Parameter exists2_es : forall {a b trace : Set},
    trace -> (a -> b -> Pervasives.result bool trace) -> list a -> list b ->
    Pervasives.result bool trace.
  
  Parameter combine_drop : forall {a b : Set}, list a -> list b -> list (a * b).
  
  Parameter combine_with_leftovers : forall {a b : Set},
    list a -> list b -> list (a * b) * option (Either.t (list a) (list b)).
  
  Parameter compare : forall {a : Set},
    (a -> a -> int) -> list a -> list a -> int.
  
  Parameter compare_lengths : forall {a b : Set}, list a -> list b -> int.
  
  Parameter compare_length_with : forall {a : Set}, list a -> int -> int.
  
  Parameter equal : forall {a : Set},
    (a -> a -> bool) -> list a -> list a -> bool.
  
  Parameter sort : forall {a : Set}, (a -> a -> int) -> list a -> list a.
  
  Parameter stable_sort : forall {a : Set}, (a -> a -> int) -> list a -> list a.
  
  Parameter fast_sort : forall {a : Set}, (a -> a -> int) -> list a -> list a.
  
  Parameter sort_uniq : forall {a : Set}, (a -> a -> int) -> list a -> list a.
  
  Parameter to_seq : forall {a : Set}, list a -> Seq.t a.
  
  Parameter of_seq : forall {a : Set}, Seq.t a -> list a.
End List.

Module _Set.
  Module S.
    Record signature {elt t : Set} : Set := {
      elt := elt;
      t := t;
      empty : t;
      is_empty : t -> bool;
      mem : elt -> t -> bool;
      add : elt -> t -> t;
      singleton : elt -> t;
      remove : elt -> t -> t;
      union : t -> t -> t;
      inter : t -> t -> t;
      disjoint : t -> t -> bool;
      diff_value : t -> t -> t;
      compare : t -> t -> int;
      equal : t -> t -> bool;
      subset : t -> t -> bool;
      iter : (elt -> unit) -> t -> unit;
      iter_e :
        forall {trace : Set},
        (elt -> Pervasives.result unit trace) -> t ->
        Pervasives.result unit trace;
      iter_s : (elt -> unit) -> t -> unit;
      iter_p : (elt -> unit) -> t -> unit;
      iter_es :
        forall {trace : Set},
        (elt -> Pervasives.result unit trace) -> t ->
        Pervasives.result unit trace;
      map : (elt -> elt) -> t -> t;
      fold : forall {a : Set}, (elt -> a -> a) -> t -> a -> a;
      fold_e :
        forall {a trace : Set},
        (elt -> a -> Pervasives.result a trace) -> t -> a ->
        Pervasives.result a trace;
      fold_s : forall {a : Set}, (elt -> a -> a) -> t -> a -> a;
      fold_es :
        forall {a trace : Set},
        (elt -> a -> Pervasives.result a trace) -> t -> a ->
        Pervasives.result a trace;
      for_all : (elt -> bool) -> t -> bool;
      _exists : (elt -> bool) -> t -> bool;
      filter : (elt -> bool) -> t -> t;
      filter_map : (elt -> option elt) -> t -> t;
      partition : (elt -> bool) -> t -> t * t;
      cardinal : t -> int;
      elements : t -> list elt;
      min_elt : t -> option elt;
      min_elt_opt : t -> option elt;
      max_elt : t -> option elt;
      max_elt_opt : t -> option elt;
      choose : t -> option elt;
      choose_opt : t -> option elt;
      split : elt -> t -> t * bool * t;
      find : elt -> t -> option elt;
      find_opt : elt -> t -> option elt;
      find_first : (elt -> bool) -> t -> option elt;
      find_first_opt : (elt -> bool) -> t -> option elt;
      find_last : (elt -> bool) -> t -> option elt;
      find_last_opt : (elt -> bool) -> t -> option elt;
      of_list : list elt -> t;
      to_seq_from : elt -> t -> Seq.t elt;
      to_seq : t -> Seq.t elt;
      to_rev_seq : t -> Seq.t elt;
      add_seq : Seq.t elt -> t -> t;
      of_seq : Seq.t elt -> t;
    }.
  End S.
  Definition S := @S.signature.
  Arguments S {_ _}.
  
  Parameter Make_t :
    forall {Ord_t : Set} (Ord : Compare.COMPARABLE (t := Ord_t)), Set.
  
  Parameter Make :
    forall {Ord_t : Set},
    forall (Ord : Compare.COMPARABLE (t := Ord_t)),
    S (elt := Ord.(Compare.COMPARABLE.t)) (t := Make_t Ord).
End _Set.

Module Map.
  Module S.
    Record signature {key : Set} {t : Set -> Set} : Set := {
      key := key;
      t := t;
      empty : forall {a : Set}, t a;
      is_empty : forall {a : Set}, t a -> bool;
      mem : forall {a : Set}, key -> t a -> bool;
      add : forall {a : Set}, key -> a -> t a -> t a;
      update : forall {a : Set}, key -> (option a -> option a) -> t a -> t a;
      singleton : forall {a : Set}, key -> a -> t a;
      remove : forall {a : Set}, key -> t a -> t a;
      merge :
        forall {a b c : Set},
        (key -> option a -> option b -> option c) -> t a -> t b -> t c;
      union :
        forall {a : Set}, (key -> a -> a -> option a) -> t a -> t a -> t a;
      compare : forall {a : Set}, (a -> a -> int) -> t a -> t a -> int;
      equal : forall {a : Set}, (a -> a -> bool) -> t a -> t a -> bool;
      iter : forall {a : Set}, (key -> a -> unit) -> t a -> unit;
      iter_e :
        forall {a trace : Set},
        (key -> a -> Pervasives.result unit trace) -> t a ->
        Pervasives.result unit trace;
      iter_s : forall {a : Set}, (key -> a -> unit) -> t a -> unit;
      iter_p : forall {a : Set}, (key -> a -> unit) -> t a -> unit;
      iter_es :
        forall {a trace : Set},
        (key -> a -> Pervasives.result unit trace) -> t a ->
        Pervasives.result unit trace;
      fold : forall {a b : Set}, (key -> a -> b -> b) -> t a -> b -> b;
      fold_e :
        forall {a b trace : Set},
        (key -> a -> b -> Pervasives.result b trace) -> t a -> b ->
        Pervasives.result b trace;
      fold_s : forall {a b : Set}, (key -> a -> b -> b) -> t a -> b -> b;
      fold_es :
        forall {a b trace : Set},
        (key -> a -> b -> Pervasives.result b trace) -> t a -> b ->
        Pervasives.result b trace;
      for_all : forall {a : Set}, (key -> a -> bool) -> t a -> bool;
      _exists : forall {a : Set}, (key -> a -> bool) -> t a -> bool;
      filter : forall {a : Set}, (key -> a -> bool) -> t a -> t a;
      filter_map : forall {a b : Set}, (key -> a -> option b) -> t a -> t b;
      partition : forall {a : Set}, (key -> a -> bool) -> t a -> t a * t a;
      cardinal : forall {a : Set}, t a -> int;
      bindings : forall {a : Set}, t a -> list (key * a);
      min_binding : forall {a : Set}, t a -> option (key * a);
      min_binding_opt : forall {a : Set}, t a -> option (key * a);
      max_binding : forall {a : Set}, t a -> option (key * a);
      max_binding_opt : forall {a : Set}, t a -> option (key * a);
      choose : forall {a : Set}, t a -> option (key * a);
      choose_opt : forall {a : Set}, t a -> option (key * a);
      split : forall {a : Set}, key -> t a -> t a * option a * t a;
      find : forall {a : Set}, key -> t a -> option a;
      find_opt : forall {a : Set}, key -> t a -> option a;
      find_first : forall {a : Set}, (key -> bool) -> t a -> option (key * a);
      find_first_opt :
        forall {a : Set}, (key -> bool) -> t a -> option (key * a);
      find_last : forall {a : Set}, (key -> bool) -> t a -> option (key * a);
      find_last_opt :
        forall {a : Set}, (key -> bool) -> t a -> option (key * a);
      map : forall {a b : Set}, (a -> b) -> t a -> t b;
      mapi : forall {a b : Set}, (key -> a -> b) -> t a -> t b;
      to_seq : forall {a : Set}, t a -> Seq.t (key * a);
      to_rev_seq : forall {a : Set}, t a -> Seq.t (key * a);
      to_seq_from : forall {a : Set}, key -> t a -> Seq.t (key * a);
      add_seq : forall {a : Set}, Seq.t (key * a) -> t a -> t a;
      of_seq : forall {a : Set}, Seq.t (key * a) -> t a;
    }.
  End S.
  Definition S := @S.signature.
  Arguments S {_ _}.
  
  Parameter Make_t :
    forall {Ord_t : Set} (Ord : Compare.COMPARABLE (t := Ord_t)), Set -> Set.
  
  Parameter Make :
    forall {Ord_t : Set},
    forall (Ord : Compare.COMPARABLE (t := Ord_t)),
    S (key := Ord.(Compare.COMPARABLE.t)) (t := Make_t Ord).
End Map.

Module Option.
  Definition t (a : Set) : Set := option a.
  
  Parameter none : forall {a : Set}, option a.
  
  Parameter none_e : forall {a trace : Set}, Pervasives.result (option a) trace.
  
  Parameter none_s : forall {a : Set}, option a.
  
  Parameter none_es : forall {a trace : Set},
    Pervasives.result (option a) trace.
  
  Parameter some : forall {a : Set}, a -> option a.
  
  Parameter some_unit : option unit.
  
  Parameter some_nil : forall {a : Set}, option (list a).
  
  Parameter some_e : forall {a trace : Set},
    a -> Pervasives.result (option a) trace.
  
  Parameter some_s : forall {a : Set}, a -> option a.
  
  Parameter some_es : forall {a trace : Set},
    a -> Pervasives.result (option a) trace.
  
  Parameter value_value : forall {a : Set}, option a -> a -> a.
  
  Parameter value_e : forall {a trace : Set},
    option a -> trace -> Pervasives.result a trace.
  
  Parameter value_f : forall {a : Set}, option a -> (unit -> a) -> a.
  
  Parameter value_fe : forall {a trace : Set},
    option a -> (unit -> trace) -> Pervasives.result a trace.
  
  Parameter bind : forall {a b : Set}, option a -> (a -> option b) -> option b.
  
  Parameter join : forall {a : Set}, option (option a) -> option a.
  
  Parameter either : forall {a : Set}, option a -> option a -> option a.
  
  Parameter map : forall {a b : Set}, (a -> b) -> option a -> option b.
  
  Parameter map_s : forall {a b : Set}, (a -> b) -> option a -> option b.
  
  Parameter map_e : forall {a b trace : Set},
    (a -> Pervasives.result b trace) -> option a ->
    Pervasives.result (option b) trace.
  
  Parameter map_es : forall {a b trace : Set},
    (a -> Pervasives.result b trace) -> option a ->
    Pervasives.result (option b) trace.
  
  Parameter fold : forall {a b : Set}, a -> (b -> a) -> option b -> a.
  
  Parameter fold_s : forall {a b : Set}, a -> (b -> a) -> option b -> a.
  
  Parameter fold_f : forall {a b : Set},
    (unit -> a) -> (b -> a) -> option b -> a.
  
  Parameter iter : forall {a : Set}, (a -> unit) -> option a -> unit.
  
  Parameter iter_s : forall {a : Set}, (a -> unit) -> option a -> unit.
  
  Parameter iter_e : forall {a trace : Set},
    (a -> Pervasives.result unit trace) -> option a ->
    Pervasives.result unit trace.
  
  Parameter iter_es : forall {a trace : Set},
    (a -> Pervasives.result unit trace) -> option a ->
    Pervasives.result unit trace.
  
  Parameter is_none : forall {a : Set}, option a -> bool.
  
  Parameter is_some : forall {a : Set}, option a -> bool.
  
  Parameter equal : forall {a : Set},
    (a -> a -> bool) -> option a -> option a -> bool.
  
  Parameter compare : forall {a : Set},
    (a -> a -> int) -> option a -> option a -> int.
  
  Parameter to_result : forall {a trace : Set},
    trace -> option a -> Pervasives.result a trace.
  
  Parameter of_result : forall {a e : Set}, Pervasives.result a e -> option a.
  
  Parameter to_list : forall {a : Set}, option a -> list a.
  
  Parameter to_seq : forall {a : Set}, option a -> Seq.t a.
  
  Parameter catch : forall {a : Set},
    option (extensible_type -> bool) -> (unit -> a) -> option a.
  
  Parameter catch_s : forall {a : Set},
    option (extensible_type -> bool) -> (unit -> a) -> option a.
End Option.

Module Result.
  Definition t (a e : Set) : Set := Pervasives.result a e.
  
  Parameter ok : forall {a e : Set}, a -> Pervasives.result a e.
  
  Parameter ok_s : forall {a e : Set}, a -> Pervasives.result a e.
  
  Parameter error_value : forall {a e : Set}, e -> Pervasives.result a e.
  
  Parameter error_s : forall {a e : Set}, e -> Pervasives.result a e.
  
  Parameter _return : forall {a e : Set}, a -> Pervasives.result a e.
  
  Parameter return_unit : forall {e : Set}, Pervasives.result unit e.
  
  Parameter return_none : forall {a e : Set}, Pervasives.result (option a) e.
  
  Parameter return_some : forall {a e : Set},
    a -> Pervasives.result (option a) e.
  
  Parameter return_nil : forall {a e : Set}, Pervasives.result (list a) e.
  
  Parameter return_true : forall {e : Set}, Pervasives.result bool e.
  
  Parameter return_false : forall {e : Set}, Pervasives.result bool e.
  
  Parameter value_value : forall {a e : Set}, Pervasives.result a e -> a -> a.
  
  Parameter value_f : forall {a e : Set},
    Pervasives.result a e -> (unit -> a) -> a.
  
  Parameter bind : forall {a b e : Set},
    Pervasives.result a e -> (a -> Pervasives.result b e) ->
    Pervasives.result b e.
  
  Parameter bind_s : forall {a b e : Set},
    Pervasives.result a e -> (a -> Pervasives.result b e) ->
    Pervasives.result b e.
  
  Parameter bind_error : forall {a e f : Set},
    Pervasives.result a e -> (e -> Pervasives.result a f) ->
    Pervasives.result a f.
  
  Parameter bind_error_s : forall {a e f : Set},
    Pervasives.result a e -> (e -> Pervasives.result a f) ->
    Pervasives.result a f.
  
  Parameter join : forall {a e : Set},
    Pervasives.result (Pervasives.result a e) e -> Pervasives.result a e.
  
  Parameter map : forall {a b e : Set},
    (a -> b) -> Pervasives.result a e -> Pervasives.result b e.
  
  Parameter map_e : forall {a b e : Set},
    (a -> Pervasives.result b e) -> Pervasives.result a e ->
    Pervasives.result b e.
  
  Parameter map_s : forall {a b e : Set},
    (a -> b) -> Pervasives.result a e -> Pervasives.result b e.
  
  Parameter map_es : forall {a b e : Set},
    (a -> Pervasives.result b e) -> Pervasives.result a e ->
    Pervasives.result b e.
  
  Parameter map_error : forall {a e f : Set},
    (e -> f) -> Pervasives.result a e -> Pervasives.result a f.
  
  Parameter map_error_e : forall {a e f : Set},
    (e -> Pervasives.result a f) -> Pervasives.result a e ->
    Pervasives.result a f.
  
  Parameter map_error_s : forall {a e f : Set},
    (e -> f) -> Pervasives.result a e -> Pervasives.result a f.
  
  Parameter map_error_es : forall {a e f : Set},
    (e -> Pervasives.result a f) -> Pervasives.result a e ->
    Pervasives.result a f.
  
  Parameter fold : forall {a c e : Set},
    (a -> c) -> (e -> c) -> Pervasives.result a e -> c.
  
  Parameter iter : forall {a e : Set},
    (a -> unit) -> Pervasives.result a e -> unit.
  
  Parameter iter_s : forall {a e : Set},
    (a -> unit) -> Pervasives.result a e -> unit.
  
  Parameter iter_error : forall {a e : Set},
    (e -> unit) -> Pervasives.result a e -> unit.
  
  Parameter iter_error_s : forall {a e : Set},
    (e -> unit) -> Pervasives.result a e -> unit.
  
  Parameter is_ok : forall {a e : Set}, Pervasives.result a e -> bool.
  
  Parameter is_error : forall {a e : Set}, Pervasives.result a e -> bool.
  
  Parameter equal : forall {a e : Set},
    (a -> a -> bool) -> (e -> e -> bool) -> Pervasives.result a e ->
    Pervasives.result a e -> bool.
  
  Parameter compare : forall {a e : Set},
    (a -> a -> int) -> (e -> e -> int) -> Pervasives.result a e ->
    Pervasives.result a e -> int.
  
  Parameter to_option : forall {a e : Set}, Pervasives.result a e -> option a.
  
  Parameter of_option : forall {a e : Set},
    e -> option a -> Pervasives.result a e.
  
  Parameter to_list : forall {a e : Set}, Pervasives.result a e -> list a.
  
  Parameter to_seq : forall {a e : Set}, Pervasives.result a e -> Seq.t a.
  
  Parameter catch : forall {a : Set},
    option (extensible_type -> bool) -> (unit -> a) ->
    Pervasives.result a extensible_type.
  
  Parameter catch_f : forall {_error a : Set},
    option (extensible_type -> bool) -> (unit -> a) ->
    (extensible_type -> _error) -> Pervasives.result a _error.
  
  Parameter catch_s : forall {a : Set},
    option (extensible_type -> bool) -> (unit -> a) ->
    Pervasives.result a extensible_type.
End Result.
